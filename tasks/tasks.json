{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Backend Infrastructure with Payload CMS and Next.js",
      "description": "Initialize the backend infrastructure using Payload CMS running on Next.js v15.1.0 with MongoDB integration as specified in the technical requirements.",
      "details": "1. Initialize a new Next.js v15.1.0 project\n2. Install and configure Payload CMS\n3. Set up MongoDB connection\n4. Configure environment variables for sensitive data\n5. Implement basic authentication system\n6. Set up Docker containerization\n7. Implement Sentry for error tracking\n8. Create basic API structure\n\nCode structure:\n```javascript\n// next.config.js\nconst { withPayload } = require('@payloadcms/next-payload');\n\nmodule.exports = withPayload({\n  // Next.js config\n  reactStrictMode: true,\n  env: {\n    MONGODB_URI: process.env.MONGODB_URI,\n    PAYLOAD_SECRET: process.env.PAYLOAD_SECRET,\n    // other env variables\n  },\n});\n\n// payload.config.ts\nimport { buildConfig } from 'payload/config';\nimport Users from './collections/Users';\n// import other collections\n\nexport default buildConfig({\n  serverURL: process.env.SERVER_URL,\n  collections: [\n    Users,\n    // other collections\n  ],\n  // other Payload config\n});\n```",
      "testStrategy": "1. Verify Next.js server starts correctly\n2. Confirm Payload CMS admin panel is accessible\n3. Test MongoDB connection\n4. Validate environment variables are properly loaded\n5. Verify Docker container builds and runs\n6. Test Sentry integration by triggering test errors\n7. Ensure basic API endpoints return expected responses",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Initialize Next.js v15.1.0 Project with Payload CMS Integration",
          "description": "Set up a new Next.js v15.1.0 project and integrate Payload CMS as the headless CMS solution",
          "dependencies": [],
          "details": "Create a new Next.js project using 'npx create-next-app@15.1.0'. Install Payload CMS with 'npm install @payloadcms/next-payload payload'. Configure next.config.js with the withPayload wrapper to enable Payload integration. Create the initial payload.config.ts file with basic configuration settings.",
          "status": "done",
          "testStrategy": "Verify the Next.js server starts correctly with 'npm run dev' and Payload admin panel is accessible at /admin route"
        },
        {
          "id": 2,
          "title": "Configure MongoDB Connection and Environment Variables",
          "description": "Set up MongoDB connection for Payload CMS and configure necessary environment variables for secure operation",
          "dependencies": [
            1
          ],
          "details": "Create a .env file with MONGODB_URI, PAYLOAD_SECRET, and SERVER_URL variables. Configure MongoDB adapter in payload.config.ts. Set up environment variable handling in next.config.js. Create a .env.example file for documentation. Implement secure handling of sensitive data using environment variables.",
          "status": "done",
          "testStrategy": "Test MongoDB connection by verifying Payload can connect to the database and perform basic CRUD operations"
        },
        {
          "id": 3,
          "title": "Implement User Authentication System",
          "description": "Create the user authentication system with Payload CMS including user collection, authentication strategies, and access control",
          "dependencies": [
            2
          ],
          "details": "Create a Users collection in /collections/Users.ts with appropriate fields and authentication configuration. Implement login, register, and password reset functionality. Configure access control policies for different user roles. Set up JWT authentication with appropriate token expiration and security settings.",
          "status": "done",
          "testStrategy": "Test user registration, login, password reset flows, and verify access control restrictions work as expected"
        },
        {
          "id": 4,
          "title": "Set Up Docker Containerization",
          "description": "Implement Docker containerization for the application to ensure consistent deployment environments",
          "dependencies": [
            3
          ],
          "details": "Create a Dockerfile that includes Node.js, MongoDB dependencies, and application code. Configure Docker Compose with services for the Next.js application and MongoDB. Set up volume mapping for persistent data storage. Configure environment variable injection for Docker environments. Implement health checks and container restart policies.",
          "status": "done",
          "testStrategy": "Build and run the Docker container locally, verify the application starts correctly and can connect to MongoDB"
        },
        {
          "id": 5,
          "title": "Integrate Sentry for Error Tracking and Create API Structure",
          "description": "Set up Sentry for error monitoring and establish the basic API structure for the application",
          "dependencies": [
            4
          ],
          "details": "Install Sentry SDK with 'npm install @sentry/nextjs'. Configure Sentry in next.config.js and create sentry.client.config.js and sentry.server.config.js files. Set up API routes under /pages/api/ or /app/api/ depending on the Next.js routing strategy. Implement error boundary components to capture and report frontend errors. Create API documentation using comments or a dedicated documentation tool.",
          "status": "done",
          "testStrategy": "Trigger test errors and verify they are properly captured in Sentry dashboard. Test API endpoints with tools like Postman or Jest to ensure they return expected responses"
        }
      ]
    },
    {
      "id": 2,
      "title": "Define Core Data Models in Payload CMS",
      "description": "Create the core data models in Payload CMS as specified in the technical requirements, including Matches, Teams, Players, Leagues, Countries, MetadataTypes, Users, and Media.",
      "details": "Create collection definitions for each data model with appropriate fields, relationships, and validation:\n\n1. Matches: Include fields for teams, score, events, status, timestamps\n2. Teams: Include name, logo, country, league relationships\n3. Players: Include personal info, team relationships, statistics\n4. Leagues: Include name, country, seasons, stages\n5. Countries: Include name, code, flag\n6. MetadataTypes: Supporting metadata for various entities\n7. Users: Authentication fields, preferences\n8. Media: Asset management for images and videos\n\nExample collection definition:\n```typescript\n// collections/Matches.ts\nimport { CollectionConfig } from 'payload/types';\n\nconst Matches: CollectionConfig = {\n  slug: 'matches',\n  admin: {\n    useAsTitle: 'matchName',\n  },\n  fields: [\n    {\n      name: 'matchName',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'homeTeam',\n      type: 'relationship',\n      relationTo: 'teams',\n      required: true,\n    },\n    {\n      name: 'awayTeam',\n      type: 'relationship',\n      relationTo: 'teams',\n      required: true,\n    },\n    {\n      name: 'homeScore',\n      type: 'number',\n      defaultValue: 0,\n    },\n    {\n      name: 'awayScore',\n      type: 'number',\n      defaultValue: 0,\n    },\n    {\n      name: 'status',\n      type: 'select',\n      options: [\n        { label: 'Not Started', value: 'not_started' },\n        { label: 'In Play', value: 'in_play' },\n        { label: 'Finished', value: 'finished' },\n        // other statuses\n      ],\n      defaultValue: 'not_started',\n      required: true,\n    },\n    {\n      name: 'events',\n      type: 'array',\n      fields: [\n        // event fields\n      ],\n    },\n    // other fields\n  ],\n};\n\nexport default Matches;\n```",
      "testStrategy": "1. Verify all collections are created in Payload CMS\n2. Test CRUD operations for each collection\n3. Validate relationships between collections\n4. Test field validations\n5. Verify indexes are properly created in MongoDB\n6. Test query performance for common data access patterns\n7. Ensure proper access control for different user roles",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Team and Country Collections",
          "description": "Define the Team and Country collection models in Payload CMS with appropriate fields and relationships.",
          "dependencies": [],
          "details": "For Teams: Implement fields for name, logo (media relationship), country (relationship), league (relationship), team code, and any team statistics. For Countries: Implement fields for name, country code (ISO), flag (media relationship), and continent. Ensure proper validation rules and admin UI configuration for both collections.",
          "status": "done",
          "testStrategy": "Verify collection creation by adding test entries through the admin UI and checking that relationships work correctly."
        },
        {
          "id": 2,
          "title": "Create Player and League Collections",
          "description": "Define the Player and League collection models with comprehensive fields and relationships to other collections.",
          "dependencies": [
            1
          ],
          "details": "For Players: Include personal information (name, DOB, nationality as relationship to Countries), team relationship, position, statistics object, and media relationships for photos. For Leagues: Include name, country relationship, seasons array, competition stages, and logo media relationship. Configure admin UI with appropriate grouping of fields.",
          "status": "done",
          "testStrategy": "Test by creating sample entries and verifying that all relationships can be properly established and that required fields are enforced."
        },
        {
          "id": 3,
          "title": "Implement Match Collection with Events",
          "description": "Create the Match collection with comprehensive fields for tracking match details, scores, and events.",
          "dependencies": [
            1,
            2
          ],
          "details": "Define the Match collection with relationships to Teams (home/away), League, and Country. Include fields for match status enum, timestamps (start/end times), scores, venue information, and an events array for tracking goals, cards, and other match events. Implement proper indexing for query performance.",
          "status": "done",
          "testStrategy": "Test by creating sample matches with different statuses and verify that all event types can be properly recorded and retrieved."
        },
        {
          "id": 4,
          "title": "Create MetadataTypes and Media Collections",
          "description": "Implement the MetadataTypes collection for supporting various entities and the Media collection for asset management.",
          "dependencies": [],
          "details": "For MetadataTypes: Create a flexible schema that can store different types of metadata with key-value pairs, entity references, and categorization. For Media: Implement asset management with fields for title, alt text, caption, file type, dimensions, and usage tracking. Configure proper file storage options and image transformations.",
          "status": "done",
          "testStrategy": "Test metadata by creating entries linked to other collections. Test media uploads with different file types and sizes to ensure proper handling."
        },
        {
          "id": 5,
          "title": "Implement User Collection with Authentication",
          "description": "Create the User collection with authentication fields, role-based permissions, and user preferences.",
          "dependencies": [
            4
          ],
          "details": "Define the User collection with fields for authentication (email, password), profile information, role-based access control (admin, editor, viewer roles), and user preferences. Implement proper password hashing, email verification, and session management. Configure access control policies for each collection based on user roles.",
          "status": "done",
          "testStrategy": "Test user registration, login, password reset flows, and verify that role-based permissions correctly restrict access to collections and operations."
        }
      ]
    },
    {
      "id": 3,
      "title": "Implement Sportmonks API Integration",
      "description": "Integrate with the Sportmonks API to fetch and synchronize soccer data for matches, teams, players, and leagues as specified in the technical requirements.",
      "details": "1. Create a service layer for Sportmonks API integration\n2. Implement authentication with Sportmonks API\n3. Create data fetching functions for different entity types\n4. Implement data transformation to match Payload CMS models\n5. Create synchronization tasks for initial data import\n6. Implement incremental updates for live data\n7. Add error handling and retry logic\n8. Implement rate limiting to respect API constraints\n\n```typescript\n// services/sportmonks.ts\nimport axios from 'axios';\n\nconst sportmonksClient = axios.create({\n  baseURL: 'https://api.sportmonks.com/v3',\n  params: {\n    api_token: process.env.SPORTMONKS_API_KEY,\n  },\n});\n\nexport async function fetchLiveMatches() {\n  try {\n    const response = await sportmonksClient.get('/fixtures/live');\n    return transformMatchData(response.data.data);\n  } catch (error) {\n    console.error('Error fetching live matches:', error);\n    throw error;\n  }\n}\n\nexport async function fetchTeams(leagueId: number) {\n  try {\n    const response = await sportmonksClient.get(`/teams/season/${leagueId}`);\n    return transformTeamData(response.data.data);\n  } catch (error) {\n    console.error(`Error fetching teams for league ${leagueId}:`, error);\n    throw error;\n  }\n}\n\n// Transform functions to convert API data to our schema\nfunction transformMatchData(matches) {\n  return matches.map(match => ({\n    // mapping logic\n  }));\n}\n\n// Other fetch and transform functions\n```",
      "testStrategy": "1. Test API authentication\n2. Verify data fetching for each entity type\n3. Test data transformation functions\n4. Validate synchronization tasks\n5. Test error handling with mocked API failures\n6. Verify rate limiting functionality\n7. Test incremental updates with sample data\n8. Measure performance and optimize if needed",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Sportmonks API Client Service",
          "description": "Implement a base API client service that handles authentication, request configuration, and common error handling for all Sportmonks API calls.",
          "dependencies": [],
          "details": "Create a service class using axios that configures the base URL, authentication headers with the API key, and implements interceptors for common error handling. Include methods for handling rate limiting, retries for failed requests, and proper logging of API interactions. Implement a request wrapper that standardizes error handling across all API calls.",
          "status": "done",
          "testStrategy": "Unit test the client with mocked API responses. Test error handling, retry logic, and authentication configuration."
        },
        {
          "id": 2,
          "title": "Implement Data Fetching Functions for Core Entities",
          "description": "Create specialized functions to fetch data for leagues, teams, players, and matches from the Sportmonks API.",
          "dependencies": [
            1
          ],
          "details": "Build upon the base client to implement specific fetching functions for each entity type. Include support for query parameters, filtering, and Sportmonks' include system for related data. Handle pagination properly to retrieve complete datasets. Implement functions for both bulk fetching (e.g., all teams in a league) and individual entity retrieval (e.g., specific match details).",
          "status": "done",
          "testStrategy": "Test each fetching function with mock responses that match Sportmonks API structure. Verify pagination handling and parameter passing."
        },
        {
          "id": 3,
          "title": "Create Data Transformation Layer",
          "description": "Implement transformation functions that convert Sportmonks API response data into the format required by Payload CMS models.",
          "dependencies": [
            2
          ],
          "details": "Create mapping functions for each entity type that transform the API response structure to match our database schema. Handle data type conversions, field renaming, and relationship mapping. Ensure all required fields are extracted and optional fields are handled appropriately. Implement validation to ensure transformed data meets our schema requirements.",
          "status": "done",
          "testStrategy": "Unit test transformers with sample API responses to verify correct mapping of all fields and proper handling of edge cases like missing data."
        },
        {
          "id": 4,
          "title": "Implement Synchronization Jobs for Initial Data Import",
          "description": "Create scheduled jobs that perform the initial synchronization of all required data from Sportmonks to populate the database.",
          "dependencies": [
            3
          ],
          "details": "Implement a synchronization service that orchestrates the full import of leagues, teams, players, and matches. Handle the proper order of imports to maintain data integrity (e.g., leagues before teams). Include progress tracking, error recovery, and the ability to resume interrupted imports. Implement batching to handle large datasets efficiently.",
          "status": "done",
          "testStrategy": "Test the synchronization process with a subset of data. Verify that all entities are properly created in the database and relationships are maintained."
        },
        {
          "id": 5,
          "title": "Implement Live Data Updates and Webhooks",
          "description": "Create a system for receiving and processing real-time updates from Sportmonks for live matches and other time-sensitive data.",
          "dependencies": [
            4
          ],
          "details": "Implement an endpoint to receive webhook notifications from Sportmonks. Create handlers for different update types (match events, score changes, etc.). Implement a polling fallback mechanism for live match updates in case webhooks fail. Ensure updates are processed efficiently and applied to the database in near real-time. Include conflict resolution for cases where updates arrive out of order.",
          "status": "done",
          "testStrategy": "Test webhook handlers with sample payloads. Verify that live updates are correctly applied to the database. Test the polling fallback mechanism by simulating webhook failures."
        }
      ]
    },
    {
      "id": 4,
      "title": "Develop Task-based Synchronization System",
      "description": "Create a task-based system for importing and updating soccer data from Sportmonks API to ensure data is current and efficiently synchronized.",
      "details": "1. Design a task queue system for data synchronization\n2. Implement scheduled tasks for different data types\n3. Create initial data import tasks\n4. Implement incremental update tasks\n5. Add logging and monitoring\n6. Implement error recovery mechanisms\n7. Create admin interface for manual sync triggers\n\n```typescript\n// tasks/syncManager.ts\nimport { CronJob } from 'cron';\nimport * as sportmonksService from '../services/sportmonks';\nimport payload from 'payload';\n\n// Task to sync live match data every minute\nexport const liveMatchSyncJob = new CronJob('* * * * *', async () => {\n  console.log('Starting live match sync...');\n  try {\n    const matches = await sportmonksService.fetchLiveMatches();\n    \n    for (const match of matches) {\n      await updateMatchInDatabase(match);\n    }\n    \n    console.log(`Synced ${matches.length} live matches`);\n  } catch (error) {\n    console.error('Error in live match sync:', error);\n  }\n});\n\n// Task to sync league data daily\nexport const leagueSyncJob = new CronJob('0 0 * * *', async () => {\n  console.log('Starting league sync...');\n  try {\n    // Sync logic for leagues\n  } catch (error) {\n    console.error('Error in league sync:', error);\n  }\n});\n\nasync function updateMatchInDatabase(match) {\n  // Find existing match or create new one\n  const existingMatch = await payload.find({\n    collection: 'matches',\n    where: {\n      externalId: { equals: match.id },\n    },\n  });\n  \n  if (existingMatch.docs.length > 0) {\n    // Update existing match\n    await payload.update({\n      collection: 'matches',\n      id: existingMatch.docs[0].id,\n      data: match,\n    });\n  } else {\n    // Create new match\n    await payload.create({\n      collection: 'matches',\n      data: match,\n    });\n  }\n}\n\n// Start all jobs\nexport function startAllSyncJobs() {\n  liveMatchSyncJob.start();\n  leagueSyncJob.start();\n  // Start other jobs\n}\n```",
      "testStrategy": "1. Test scheduled task execution\n2. Verify data is correctly imported into the database\n3. Test incremental updates with sample data\n4. Validate error handling and recovery\n5. Test manual sync triggers\n6. Verify logging and monitoring\n7. Test performance under load\n8. Verify data consistency after synchronization",
      "priority": "medium",
      "dependencies": [
        3
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Task Queue System",
          "description": "Design and implement a task queue system that can manage synchronization jobs with proper prioritization, scheduling, and execution tracking.",
          "dependencies": [],
          "details": "Create a TaskQueue class that maintains a queue of pending tasks with priority levels. Implement methods for adding tasks to the queue, processing tasks sequentially, and handling task completion/failure. Use a singleton pattern to ensure a single queue instance throughout the application. Include status tracking for each task (pending, in-progress, completed, failed).",
          "status": "done",
          "testStrategy": "Unit test the TaskQueue class with mock tasks to verify proper queuing, prioritization, and execution. Test edge cases like empty queue, task failures, and concurrent task additions."
        },
        {
          "id": 2,
          "title": "Create Entity-Specific Sync Handlers",
          "description": "Develop specialized handlers for each entity type (leagues, teams, players, matches, etc.) that implement consistent interfaces for data fetching, transformation, and database operations.",
          "dependencies": [
            1
          ],
          "details": "Create an abstract SyncHandler base class with methods like fetchData(), transformData(), and saveToDatabase(). Implement concrete handlers for each entity type (LeagueHandler, TeamHandler, etc.) that extend this base class. Each handler should handle entity-specific API endpoints, data transformation logic, and database operations while maintaining a consistent interface.",
          "status": "done",
          "testStrategy": "Test each handler with mock API responses to verify proper data transformation. Create integration tests that use test database instances to verify the full sync process for each entity type."
        },
        {
          "id": 3,
          "title": "Implement Scheduled and Manual Sync Triggers",
          "description": "Create a system for scheduling regular sync jobs and an admin interface for triggering manual synchronization of specific entity types.",
          "dependencies": [
            1,
            2
          ],
          "details": "Extend the existing CronJob implementation to use the TaskQueue for scheduling regular sync jobs with different frequencies based on data type (e.g., live matches every minute, leagues daily). Create API endpoints for manual sync triggers that can be called from an admin interface. Implement a simple admin dashboard component that displays sync status and allows triggering manual syncs.",
          "status": "done",
          "testStrategy": "Test scheduled triggers by mocking the time and verifying jobs are added to the queue at expected intervals. Test manual triggers via API endpoint tests that verify proper task creation."
        },
        {
          "id": 4,
          "title": "Add Comprehensive Logging and Error Recovery",
          "description": "Implement detailed logging for all sync operations and create error recovery mechanisms to handle API failures, rate limiting, and database errors.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Create a SyncLogger class that records detailed information about each sync operation, including timing, record counts, and error details. Implement retry logic for failed API requests with exponential backoff. Add transaction support for database operations to ensure data consistency. Create a monitoring dashboard that displays sync statistics and alerts for repeated failures. Implement a mechanism to resume interrupted syncs from the last successful point.",
          "status": "done",
          "testStrategy": "Test error scenarios by mocking API failures, rate limit responses, and database errors. Verify that the system properly logs these events and implements appropriate retry/recovery strategies."
        }
      ]
    },
    {
      "id": 5,
      "title": "Create RESTful API Endpoints",
      "description": "Develop RESTful API endpoints to expose soccer data to client applications, implementing the necessary routes, controllers, and middleware.",
      "details": "1. Design API routes for all data entities\n2. Implement controllers for each route\n3. Add authentication middleware\n4. Implement pagination for large datasets\n5. Add filtering and sorting capabilities\n6. Implement rate limiting\n7. Add error handling middleware\n8. Create API documentation\n\n```typescript\n// api/matches.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport payload from 'payload';\nimport { authenticateRequest } from '../middleware/auth';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  // Apply authentication middleware\n  const authResult = await authenticateRequest(req, res);\n  if (!authResult.success) return;\n  \n  try {\n    switch (req.method) {\n      case 'GET':\n        // Parse query parameters\n        const { page = 1, limit = 10, league, team, status } = req.query;\n        \n        // Build query\n        const query: any = {};\n        if (league) query.league = { equals: league };\n        if (team) query['or'] = [\n          { homeTeam: { equals: team } },\n          { awayTeam: { equals: team } },\n        ];\n        if (status) query.status = { equals: status };\n        \n        // Execute query with pagination\n        const matches = await payload.find({\n          collection: 'matches',\n          where: query,\n          page: Number(page),\n          limit: Number(limit),\n          sort: '-startTime',\n        });\n        \n        return res.status(200).json(matches);\n        \n      default:\n        return res.status(405).json({ error: 'Method not allowed' });\n    }\n  } catch (error) {\n    console.error('API error:', error);\n    return res.status(500).json({ error: 'Internal server error' });\n  }\n}\n```",
      "testStrategy": "1. Test all API endpoints with valid requests\n2. Verify authentication works correctly\n3. Test pagination with large datasets\n4. Verify filtering and sorting functionality\n5. Test error handling with invalid requests\n6. Verify rate limiting functionality\n7. Test API performance under load\n8. Validate API documentation against actual implementation",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "in-progress",
      "subtasks": [
        {
          "id": 1,
          "title": "Design API Route Structure and Authentication Flow",
          "description": "Define the complete API route structure for all entities (leagues, teams, players, matches, countries, Wave Detector, Memory Avenues) and design the authentication flow for securing these endpoints.",
          "dependencies": [],
          "details": "Create a comprehensive API route map document that outlines all endpoints, HTTP methods, required parameters, and expected responses. Define authentication requirements for each endpoint, specifying which routes require authentication and what permission levels are needed. Design JWT token structure and authentication flow.\n<info added on 2025-05-04T03:07:25.931Z>\nCreate a comprehensive API route map document that outlines all endpoints, HTTP methods, required parameters, and expected responses. Define authentication requirements for each endpoint, specifying which routes require authentication and what permission levels are needed. Design JWT token structure and authentication flow.\n\nProgress has been made with the initial API structure setup in the /src/app/api/v1 directory. The first endpoint for teams with various views has been implemented, and an authentication utility has been established in utilities/auth.js.\n\nRemaining tasks include:\n1. Complete the comprehensive API route map document covering all entities (leagues, teams, players, matches, countries, Wave Detector, Memory Avenues)\n2. Finalize the JWT-based authentication flow design with special consideration for mobile client requirements\n3. Define detailed parameter structures and standardized response formats for all endpoints\n4. Document the relationships and dependencies between different entity endpoints\n5. Ensure the authentication utility in utilities/auth.js properly integrates with all planned endpoints\n6. Prepare for handoff to the Core Entity Controllers implementation team\n</info added on 2025-05-04T03:07:25.931Z>",
          "status": "in-progress",
          "testStrategy": "Create Postman collection with authentication tests and document expected responses for each endpoint."
        },
        {
          "id": 2,
          "title": "Implement Core Entity Controllers (Teams, Leagues, Players)",
          "description": "Develop controllers for the core entities including teams, leagues, and players with full CRUD operations where appropriate.",
          "dependencies": [
            1
          ],
          "details": "Create separate controller files for each entity. Implement GET (list and detail), POST, PUT, and DELETE methods as needed. Include query parameter handling for filtering, sorting, and pagination. Ensure proper error handling and response formatting.\n<info added on 2025-05-04T03:07:08.905Z>\nCreate separate controller files for each entity. Implement GET (list and detail), POST, PUT, and DELETE methods as needed. Include query parameter handling for filtering, sorting, and pagination. Ensure proper error handling and response formatting.\n\nProgress Update:\n- Teams API endpoint has been implemented in src/app/api/v1/teams.ts\n- Teams endpoint supports multiple views (overview, fixtures, stats)\n- Implemented pagination, filtering, and proper error handling for Teams\n- Following established API development best practices\n\nRemaining Tasks:\n1. Implement Leagues API endpoints:\n   - Create controller file at src/app/api/v1/leagues.ts\n   - Implement GET endpoints for list and detail views\n   - Add specialized views (standings, seasons, participating teams)\n   - Implement POST, PUT, DELETE operations\n   - Add pagination, filtering, and sorting functionality\n   - Ensure proper error handling and response formatting\n\n2. Implement Players API endpoints:\n   - Create controller file at src/app/api/v1/players.ts\n   - Implement GET endpoints for list and detail views\n   - Add specialized views (stats, career history, current team)\n   - Implement POST, PUT, DELETE operations\n   - Add pagination, filtering, and sorting functionality\n   - Ensure proper error handling and response formatting\n\n3. Review and complete any remaining CRUD operations:\n   - Verify all required operations are implemented for each entity\n   - Ensure consistent response formatting across all endpoints\n   - Check that error handling is comprehensive\n</info added on 2025-05-04T03:07:08.905Z>",
          "status": "in-progress",
          "testStrategy": "Unit test each controller method with mock data. Test pagination, filtering, and sorting functionality."
        },
        {
          "id": 3,
          "title": "Implement Match and Game Data Controllers",
          "description": "Develop controllers for match data, game statistics, and related entities with appropriate query capabilities.",
          "dependencies": [
            2
          ],
          "details": "Create controllers for matches, game statistics, and related data. Implement complex queries for filtering matches by team, league, date range, and status. Add specialized endpoints for upcoming matches, live matches, and historical results. Include aggregation endpoints for team performance statistics.",
          "status": "pending",
          "testStrategy": "Test match filtering with various parameter combinations. Verify performance with large datasets."
        },
        {
          "id": 4,
          "title": "Implement Specialized Feature Controllers (Wave Detector, Memory Avenues)",
          "description": "Develop controllers for specialized features like Wave Detector and Memory Avenues with appropriate data transformation logic.",
          "dependencies": [
            2
          ],
          "details": "Create controllers for Wave Detector data access and Memory Avenues. Implement specialized business logic for data transformation and analysis. Add endpoints for trend analysis, historical comparisons, and user-specific data views.",
          "status": "pending",
          "testStrategy": "Test data transformation logic with known input/output pairs. Verify performance with realistic data volumes."
        },
        {
          "id": 5,
          "title": "Implement Authentication and Authorization Middleware",
          "description": "Develop middleware for JWT authentication, role-based authorization, and request validation.",
          "dependencies": [
            1
          ],
          "details": "Create middleware functions for verifying JWT tokens, checking user permissions based on roles, and validating request parameters. Implement token refresh logic and secure token storage. Add middleware for handling CORS and other security headers.",
          "status": "pending",
          "testStrategy": "Test middleware with valid and invalid tokens. Verify correct behavior for different user roles and permission levels."
        },
        {
          "id": 6,
          "title": "Implement API Performance Optimizations",
          "description": "Add pagination, caching, and rate limiting to optimize API performance and prevent abuse.",
          "dependencies": [
            2,
            3,
            4,
            5
          ],
          "details": "Implement consistent pagination across all list endpoints with customizable page size. Add response caching for frequently accessed and rarely changing data. Implement rate limiting with different tiers based on user roles. Add compression middleware for reducing response size.",
          "status": "pending",
          "testStrategy": "Load test endpoints with and without optimizations. Verify rate limiting behavior with rapid successive requests."
        },
        {
          "id": 7,
          "title": "Implement Error Handling and Logging",
          "description": "Develop comprehensive error handling middleware and logging for all API endpoints.",
          "dependencies": [
            2,
            3,
            4,
            5
          ],
          "details": "Create centralized error handling middleware that catches all exceptions and returns appropriate HTTP status codes and error messages. Implement structured logging for all API requests, responses, and errors. Add correlation IDs for request tracing across the system.",
          "status": "pending",
          "testStrategy": "Test error handling by triggering various error conditions. Verify logs contain all necessary information for debugging."
        },
        {
          "id": 8,
          "title": "Create API Documentation and Developer Resources",
          "description": "Generate comprehensive API documentation and developer resources for API consumers.",
          "dependencies": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "details": "Use Swagger/OpenAPI to document all API endpoints, parameters, and response schemas. Create example requests and responses for each endpoint. Add authentication instructions and error code references. Generate interactive API documentation that allows testing endpoints directly from the documentation.",
          "status": "pending",
          "testStrategy": "Verify documentation accuracy by comparing with actual API behavior. Test documentation examples to ensure they work as described."
        }
      ]
    },
    {
      "id": 6,
      "title": "Implement Wave Detector Algorithm",
      "description": "Develop the Wave Detector algorithm that calculates match significance (1-100 rating) based on various factors to help users identify which matches deserve attention.",
      "details": "1. Define factors that contribute to match significance\n2. Implement scoring algorithm for each factor\n3. Create weighted scoring system\n4. Implement real-time score updates\n5. Add personalization adjustments based on user preferences\n6. Create visualization data for wave representation\n7. Implement Rising Tides detection for emerging significant matches\n\n```typescript\n// services/waveDetector.ts\n\ninterface WaveFactors {\n  scoreDifference: number;\n  timeRemaining: number;\n  leagueImportance: number;\n  rivalryFactor: number;\n  tableImpact: number;\n  recentGoals: number;\n  redCards: number;\n  userPreferences: any;\n  // other factors\n}\n\nexport function calculateWaveScore(match: any, userPreferences?: any): number {\n  // Extract match data\n  const factors: WaveFactors = {\n    scoreDifference: Math.abs(match.homeScore - match.awayScore),\n    timeRemaining: calculateTimeRemaining(match),\n    leagueImportance: getLeagueImportance(match.league),\n    rivalryFactor: getRivalryFactor(match.homeTeam, match.awayTeam),\n    tableImpact: calculateTableImpact(match),\n    recentGoals: countRecentGoals(match),\n    redCards: countRedCards(match),\n    userPreferences: userPreferences || {},\n  };\n  \n  // Base score calculation\n  let baseScore = 0;\n  \n  // Close score in late game\n  if (factors.scoreDifference <= 1 && factors.timeRemaining < 15) {\n    baseScore += 30;\n  }\n  \n  // Recent goals increase excitement\n  baseScore += factors.recentGoals * 15;\n  \n  // Red cards impact game dynamics\n  baseScore += factors.redCards * 10;\n  \n  // League importance factor\n  baseScore *= (0.5 + (factors.leagueImportance * 0.5));\n  \n  // Rivalry bonus\n  baseScore += factors.rivalryFactor * 15;\n  \n  // Table impact\n  baseScore += factors.tableImpact * 10;\n  \n  // Apply user preferences\n  baseScore = applyUserPreferences(baseScore, factors);\n  \n  // Ensure score is between 1-100\n  return Math.max(1, Math.min(100, Math.round(baseScore)));\n}\n\nfunction applyUserPreferences(score: number, factors: WaveFactors): number {\n  let adjustedScore = score;\n  \n  // Boost score for favorite teams\n  if (factors.userPreferences.favoriteTeams?.includes(factors.homeTeam) || \n      factors.userPreferences.favoriteTeams?.includes(factors.awayTeam)) {\n    adjustedScore *= 1.2;\n  }\n  \n  // Boost score for favorite leagues\n  if (factors.userPreferences.favoriteLeagues?.includes(factors.league)) {\n    adjustedScore *= 1.1;\n  }\n  \n  return adjustedScore;\n}\n\n// Helper functions for each factor calculation\nfunction calculateTimeRemaining(match: any): number {\n  // Implementation\n}\n\nfunction getLeagueImportance(leagueId: string): number {\n  // Implementation\n}\n\n// Other helper functions\n```",
      "testStrategy": "1. Test algorithm with various match scenarios\n2. Verify all factors are correctly calculated\n3. Test personalization adjustments\n4. Validate Rising Tides detection\n5. Test performance with multiple concurrent calculations\n6. Verify real-time updates work correctly\n7. Test edge cases (e.g., very high or low scores)\n8. Validate visualization data format",
      "priority": "high",
      "dependencies": [
        3,
        4
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Develop Memory Avenues Feature",
      "description": "Create the Memory Avenues feature that transforms match data into connected pathways through key moments and narratives, creating a storytelling experience around matches.",
      "details": "1. Design data structure for match narratives\n2. Implement moment identification algorithm\n3. Create thematic route generation (tactical, emotional, statistical)\n4. Develop pivotal moment highlighting\n5. Implement quick journey navigation\n6. Create avenue sharing capabilities\n7. Add personalization based on user preferences\n\n```typescript\n// services/memoryAvenues.ts\n\ninterface MatchMoment {\n  id: string;\n  timestamp: number;\n  type: 'goal' | 'card' | 'substitution' | 'chance' | 'tactical' | 'other';\n  description: string;\n  importance: number; // 1-10\n  teams: { home: boolean, away: boolean }; // Which team(s) this moment relates to\n  players: string[]; // Player IDs involved\n  media?: string; // Media asset ID if available\n}\n\ninterface Avenue {\n  id: string;\n  matchId: string;\n  type: 'main' | 'tactical' | 'emotional' | 'statistical';\n  title: string;\n  description: string;\n  moments: MatchMoment[];\n  estimatedReadTime: number; // in minutes\n}\n\nexport async function generateMatchAvenues(matchId: string): Promise<Avenue[]> {\n  // Fetch match data\n  const match = await fetchMatchWithEvents(matchId);\n  \n  // Generate different avenue types\n  const avenues: Avenue[] = [\n    await generateMainAvenue(match),\n    await generateTacticalAvenue(match),\n    await generateEmotionalAvenue(match),\n    await generateStatisticalAvenue(match),\n  ];\n  \n  return avenues;\n}\n\nasync function generateMainAvenue(match: any): Promise<Avenue> {\n  // Identify key moments\n  const moments = identifyKeyMoments(match);\n  \n  // Sort by importance and timestamp\n  const sortedMoments = moments\n    .sort((a, b) => b.importance - a.importance || a.timestamp - b.timestamp)\n    .slice(0, 10); // Limit to top 10 moments\n  \n  // Calculate read time (30 seconds per moment)\n  const estimatedReadTime = Math.ceil(sortedMoments.length * 0.5);\n  \n  return {\n    id: `main-${match.id}`,\n    matchId: match.id,\n    type: 'main',\n    title: `${match.homeTeam.name} vs ${match.awayTeam.name} Story`,\n    description: generateMatchDescription(match),\n    moments: sortedMoments,\n    estimatedReadTime,\n  };\n}\n\nfunction identifyKeyMoments(match: any): MatchMoment[] {\n  const moments: MatchMoment[] = [];\n  \n  // Process goals\n  match.events\n    .filter(event => event.type === 'goal')\n    .forEach(goal => {\n      moments.push({\n        id: `goal-${goal.id}`,\n        timestamp: goal.minute,\n        type: 'goal',\n        description: generateGoalDescription(goal, match),\n        importance: calculateGoalImportance(goal, match),\n        teams: { \n          home: goal.team_id === match.homeTeam.id,\n          away: goal.team_id === match.awayTeam.id\n        },\n        players: [goal.player_id],\n        media: goal.media_id,\n      });\n    });\n  \n  // Process other event types similarly\n  // ...\n  \n  return moments;\n}\n\n// Helper functions for avenue generation\nfunction generateMatchDescription(match: any): string {\n  // Implementation\n}\n\nfunction calculateGoalImportance(goal: any, match: any): number {\n  // Implementation\n}\n\n// Other helper functions and avenue generators\n```",
      "testStrategy": "1. Test avenue generation with various match types\n2. Verify moment identification works correctly\n3. Test thematic route generation\n4. Validate pivotal moment highlighting\n5. Test journey navigation functionality\n6. Verify avenue sharing capabilities\n7. Test personalization based on user preferences\n8. Validate estimated read times",
      "priority": "medium",
      "dependencies": [
        3,
        4
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement User Authentication and Preferences",
      "description": "Develop the user authentication system and preference management to allow users to create accounts, log in, and personalize their experience.",
      "details": "1. Implement user registration flow\n2. Create login functionality\n3. Add social login options\n4. Implement password reset\n5. Create user preference management\n6. Add favorite teams, leagues, and players functionality\n7. Implement anonymous mode for non-registered users\n8. Add account deletion functionality\n\n```typescript\n// collections/Users.ts\nimport { CollectionConfig } from 'payload/types';\n\nconst Users: CollectionConfig = {\n  slug: 'users',\n  auth: {\n    useAPIKey: true,\n  },\n  admin: {\n    useAsTitle: 'email',\n  },\n  access: {\n    read: ({ req: { user } }) => {\n      // Users can only read their own document\n      if (user) {\n        return {\n          id: {\n            equals: user.id,\n          },\n        };\n      }\n      return false;\n    },\n  },\n  fields: [\n    {\n      name: 'email',\n      type: 'email',\n      required: true,\n      unique: true,\n    },\n    {\n      name: 'favoriteTeams',\n      type: 'relationship',\n      relationTo: 'teams',\n      hasMany: true,\n    },\n    {\n      name: 'favoriteLeagues',\n      type: 'relationship',\n      relationTo: 'leagues',\n      hasMany: true,\n    },\n    {\n      name: 'favoritePlayers',\n      type: 'relationship',\n      relationTo: 'players',\n      hasMany: true,\n    },\n    {\n      name: 'notificationPreferences',\n      type: 'group',\n      fields: [\n        {\n          name: 'goals',\n          type: 'checkbox',\n          defaultValue: true,\n        },\n        {\n          name: 'matchStart',\n          type: 'checkbox',\n          defaultValue: true,\n        },\n        {\n          name: 'highWaveScore',\n          type: 'checkbox',\n          defaultValue: true,\n        },\n        {\n          name: 'waveScoreThreshold',\n          type: 'number',\n          min: 1,\n          max: 100,\n          defaultValue: 70,\n        },\n      ],\n    },\n    // Other preference fields\n  ],\n};\n\nexport default Users;\n\n// api/preferences.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport payload from 'payload';\nimport { authenticateRequest } from '../middleware/auth';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  // Apply authentication middleware\n  const authResult = await authenticateRequest(req, res);\n  if (!authResult.success) return;\n  \n  const userId = authResult.user.id;\n  \n  try {\n    switch (req.method) {\n      case 'GET':\n        const user = await payload.findByID({\n          collection: 'users',\n          id: userId,\n        });\n        \n        return res.status(200).json({\n          favoriteTeams: user.favoriteTeams,\n          favoriteLeagues: user.favoriteLeagues,\n          favoritePlayers: user.favoritePlayers,\n          notificationPreferences: user.notificationPreferences,\n        });\n        \n      case 'PATCH':\n        const updatedUser = await payload.update({\n          collection: 'users',\n          id: userId,\n          data: req.body,\n        });\n        \n        return res.status(200).json({\n          success: true,\n          message: 'Preferences updated successfully',\n        });\n        \n      default:\n        return res.status(405).json({ error: 'Method not allowed' });\n    }\n  } catch (error) {\n    console.error('API error:', error);\n    return res.status(500).json({ error: 'Internal server error' });\n  }\n}\n```",
      "testStrategy": "1. Test user registration flow\n2. Verify login functionality\n3. Test social login integration\n4. Validate password reset functionality\n5. Test preference management\n6. Verify favorites functionality\n7. Test anonymous mode\n8. Validate account deletion\n9. Test security measures (password hashing, JWT validation)\n10. Verify data privacy compliance",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement Push Notification System",
      "description": "Develop a push notification system to alert users about goals, high Wave Scores, and other important events in matches they're following.",
      "details": "1. Set up push notification infrastructure\n2. Implement notification triggers for different events\n3. Create notification templates\n4. Add user subscription management\n5. Implement notification preferences\n6. Create notification delivery service\n7. Add tracking for notification engagement\n\n```typescript\n// services/notifications.ts\nimport * as admin from 'firebase-admin';\nimport payload from 'payload';\n\n// Initialize Firebase Admin SDK\nif (!admin.apps.length) {\n  admin.initializeApp({\n    credential: admin.credential.cert({\n      projectId: process.env.FIREBASE_PROJECT_ID,\n      clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n      privateKey: process.env.FIREBASE_PRIVATE_KEY.replace(/\\\\n/g, '\\n'),\n    }),\n  });\n}\n\ninterface NotificationData {\n  type: 'goal' | 'matchStart' | 'highWaveScore' | 'matchEnd';\n  matchId: string;\n  title: string;\n  body: string;\n  data?: Record<string, string>;\n}\n\nexport async function sendNotification(userId: string, notification: NotificationData): Promise<boolean> {\n  try {\n    // Get user device tokens and preferences\n    const user = await payload.findByID({\n      collection: 'users',\n      id: userId,\n    });\n    \n    // Check if user has enabled this notification type\n    if (!user.notificationPreferences?.[notification.type]) {\n      return false;\n    }\n    \n    // Check if user has device tokens\n    if (!user.deviceTokens || user.deviceTokens.length === 0) {\n      return false;\n    }\n    \n    // Send to all user devices\n    const message = {\n      notification: {\n        title: notification.title,\n        body: notification.body,\n      },\n      data: notification.data || {},\n      tokens: user.deviceTokens,\n    };\n    \n    const response = await admin.messaging().sendMulticast(message);\n    \n    // Log notification for analytics\n    await payload.create({\n      collection: 'notifications',\n      data: {\n        user: userId,\n        type: notification.type,\n        matchId: notification.matchId,\n        title: notification.title,\n        body: notification.body,\n        sentAt: new Date().toISOString(),\n        successCount: response.successCount,\n        failureCount: response.failureCount,\n      },\n    });\n    \n    return response.successCount > 0;\n  } catch (error) {\n    console.error('Error sending notification:', error);\n    return false;\n  }\n}\n\nexport async function notifyGoal(matchId: string, goalData: any): Promise<void> {\n  // Get match details\n  const match = await payload.findByID({\n    collection: 'matches',\n    id: matchId,\n  });\n  \n  // Find users who follow either team\n  const users = await payload.find({\n    collection: 'users',\n    where: {\n      'or': [\n        { 'favoriteTeams.contains': match.homeTeam.id },\n        { 'favoriteTeams.contains': match.awayTeam.id },\n      ],\n    },\n  });\n  \n  // Create notification\n  const notification: NotificationData = {\n    type: 'goal',\n    matchId,\n    title: 'GOAL!',\n    body: `${goalData.team.name} scored! ${match.homeTeam.name} ${match.homeScore}-${match.awayScore} ${match.awayTeam.name}`,\n    data: {\n      matchId,\n      screen: 'MatchDetails',\n    },\n  };\n  \n  // Send to all relevant users\n  for (const user of users.docs) {\n    await sendNotification(user.id, notification);\n  }\n}\n\n// Other notification functions\n```",
      "testStrategy": "1. Test notification infrastructure setup\n2. Verify notification triggers for different events\n3. Test notification templates\n4. Validate user subscription management\n5. Test notification preferences\n6. Verify notification delivery\n7. Test tracking for notification engagement\n8. Validate notification throttling to prevent spam\n9. Test notification deep linking\n10. Verify notification analytics",
      "priority": "medium",
      "dependencies": [
        6,
        8
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Initialize React Native Mobile App",
      "description": "Set up the React Native mobile application for iOS and Android platforms with the necessary configuration, navigation, and state management.",
      "details": "1. Initialize React Native project\n2. Configure iOS and Android platforms\n3. Set up navigation system\n4. Implement state management\n5. Create API client for backend communication\n6. Set up authentication flow\n7. Implement push notification handling\n8. Configure app icons and splash screens\n\n```javascript\n// App.js\nimport React from 'react';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\nimport { Provider } from 'react-redux';\nimport { PersistGate } from 'redux-persist/integration/react';\n\nimport { store, persistor } from './src/store';\nimport AuthScreen from './src/screens/AuthScreen';\nimport HomeScreen from './src/screens/HomeScreen';\nimport MatchesScreen from './src/screens/MatchesScreen';\nimport MatchDetailsScreen from './src/screens/MatchDetailsScreen';\nimport ProfileScreen from './src/screens/ProfileScreen';\nimport { useAuth } from './src/hooks/useAuth';\n\nconst Stack = createNativeStackNavigator();\nconst Tab = createBottomTabNavigator();\n\nfunction MainTabs() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name=\"Home\" component={HomeScreen} />\n      <Tab.Screen name=\"Matches\" component={MatchesScreen} />\n      <Tab.Screen name=\"Profile\" component={ProfileScreen} />\n    </Tab.Navigator>\n  );\n}\n\nfunction AppNavigator() {\n  const { isAuthenticated, isLoading } = useAuth();\n  \n  if (isLoading) {\n    return <SplashScreen />;\n  }\n  \n  return (\n    <NavigationContainer>\n      <Stack.Navigator>\n        {!isAuthenticated ? (\n          <Stack.Screen \n            name=\"Auth\" \n            component={AuthScreen} \n            options={{ headerShown: false }}\n          />\n        ) : (\n          <>\n            <Stack.Screen \n              name=\"Main\" \n              component={MainTabs} \n              options={{ headerShown: false }}\n            />\n            <Stack.Screen \n              name=\"MatchDetails\" \n              component={MatchDetailsScreen}\n            />\n            {/* Other authenticated screens */}\n          </>\n        )}\n      </Stack.Navigator>\n    </NavigationContainer>\n  );\n}\n\nexport default function App() {\n  return (\n    <Provider store={store}>\n      <PersistGate loading={null} persistor={persistor}>\n        <AppNavigator />\n      </PersistGate>\n    </Provider>\n  );\n}\n\n// src/api/client.js\nimport axios from 'axios';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\nconst API_URL = 'https://api.futave.com';\n\nconst apiClient = axios.create({\n  baseURL: API_URL,\n  timeout: 10000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// Add token to requests\napiClient.interceptors.request.use(\n  async (config) => {\n    const token = await AsyncStorage.getItem('auth_token');\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    return config;\n  },\n  (error) => Promise.reject(error)\n);\n\nexport default apiClient;\n```",
      "testStrategy": "1. Verify React Native project initialization\n2. Test iOS and Android builds\n3. Validate navigation system\n4. Test state management\n5. Verify API client functionality\n6. Test authentication flow\n7. Validate push notification handling\n8. Test app icons and splash screens\n9. Verify deep linking\n10. Test app performance on various devices",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Implement Score Navigation Interface",
      "description": "Develop the core score navigation interface that provides a streamlined, distraction-free view of match scores with intuitive navigation between leagues, teams, and matches.",
      "details": "1. Create match list component\n2. Implement league navigation\n3. Develop match card component\n4. Add favorite filtering\n5. Implement live score updates\n6. Create match status indicators\n7. Add pull-to-refresh functionality\n8. Implement smooth animations\n\n```javascript\n// src/screens/MatchesScreen.js\nimport React, { useState, useEffect } from 'react';\nimport { View, FlatList, StyleSheet, ActivityIndicator, RefreshControl } from 'react-native';\nimport { useSelector, useDispatch } from 'react-redux';\n\nimport LeagueSelector from '../components/LeagueSelector';\nimport MatchCard from '../components/MatchCard';\nimport FilterBar from '../components/FilterBar';\nimport { fetchMatches, refreshMatches } from '../store/actions/matchActions';\n\nconst MatchesScreen = ({ navigation }) => {\n  const [selectedLeague, setSelectedLeague] = useState('all');\n  const [filter, setFilter] = useState('all'); // all, live, upcoming, finished\n  const [refreshing, setRefreshing] = useState(false);\n  \n  const dispatch = useDispatch();\n  const { matches, loading, error } = useSelector(state => state.matches);\n  const { favorites } = useSelector(state => state.user);\n  \n  useEffect(() => {\n    dispatch(fetchMatches(selectedLeague, filter));\n    \n    // Set up polling for live matches\n    const interval = setInterval(() => {\n      if (filter === 'live') {\n        dispatch(fetchMatches(selectedLeague, filter, true)); // silent update\n      }\n    }, 30000); // 30 seconds\n    \n    return () => clearInterval(interval);\n  }, [dispatch, selectedLeague, filter]);\n  \n  const handleRefresh = async () => {\n    setRefreshing(true);\n    await dispatch(refreshMatches(selectedLeague, filter));\n    setRefreshing(false);\n  };\n  \n  const handleMatchPress = (match) => {\n    navigation.navigate('MatchDetails', { matchId: match.id });\n  };\n  \n  const filteredMatches = matches.filter(match => {\n    if (filter === 'live') return match.status === 'in_play';\n    if (filter === 'upcoming') return match.status === 'not_started';\n    if (filter === 'finished') return match.status === 'finished';\n    if (filter === 'favorites') {\n      return favorites.teams.includes(match.homeTeam.id) || \n             favorites.teams.includes(match.awayTeam.id);\n    }\n    return true;\n  });\n  \n  return (\n    <View style={styles.container}>\n      <LeagueSelector\n        selectedLeague={selectedLeague}\n        onSelectLeague={setSelectedLeague}\n      />\n      \n      <FilterBar\n        selectedFilter={filter}\n        onSelectFilter={setFilter}\n      />\n      \n      {loading && !refreshing ? (\n        <ActivityIndicator size=\"large\" color=\"#0000ff\" />\n      ) : (\n        <FlatList\n          data={filteredMatches}\n          keyExtractor={item => item.id.toString()}\n          renderItem={({ item }) => (\n            <MatchCard \n              match={item} \n              onPress={() => handleMatchPress(item)}\n              isFavorite={favorites.teams.includes(item.homeTeam.id) || \n                         favorites.teams.includes(item.awayTeam.id)}\n            />\n          )}\n          refreshControl={\n            <RefreshControl\n              refreshing={refreshing}\n              onRefresh={handleRefresh}\n            />\n          }\n          ListEmptyComponent={\n            <View style={styles.emptyContainer}>\n              <Text style={styles.emptyText}>\n                No matches found for the selected filters\n              </Text>\n            </View>\n          }\n        />\n      )}\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#f5f5f5',\n  },\n  emptyContainer: {\n    padding: 20,\n    alignItems: 'center',\n  },\n  emptyText: {\n    fontSize: 16,\n    color: '#666',\n  },\n});\n\nexport default MatchesScreen;\n\n// src/components/MatchCard.js\nimport React from 'react';\nimport { View, Text, TouchableOpacity, StyleSheet } from 'react-native';\nimport { useDispatch } from 'react-redux';\nimport Icon from 'react-native-vector-icons/MaterialCommunityIcons';\n\nimport { toggleFavoriteTeam } from '../store/actions/userActions';\n\nconst MatchCard = ({ match, onPress, isFavorite }) => {\n  const dispatch = useDispatch();\n  \n  const handleFavoritePress = (teamId) => {\n    dispatch(toggleFavoriteTeam(teamId));\n  };\n  \n  const getStatusText = () => {\n    if (match.status === 'in_play') {\n      return `${match.minute}'`;\n    } else if (match.status === 'not_started') {\n      return new Date(match.startTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });\n    } else {\n      return 'FT';\n    }\n  };\n  \n  return (\n    <TouchableOpacity style={styles.card} onPress={onPress}>\n      <View style={styles.statusContainer}>\n        <Text style={[styles.status, match.status === 'in_play' && styles.liveStatus]}>\n          {getStatusText()}\n        </Text>\n      </View>\n      \n      <View style={styles.teamsContainer}>\n        <View style={styles.teamRow}>\n          <TouchableOpacity\n            style={styles.favoriteButton}\n            onPress={() => handleFavoritePress(match.homeTeam.id)}\n          >\n            <Icon \n              name={favorites.teams.includes(match.homeTeam.id) ? 'star' : 'star-outline'} \n              size={16} \n              color=\"#FFD700\" \n            />\n          </TouchableOpacity>\n          <Text style={styles.teamName}>{match.homeTeam.name}</Text>\n          <Text style={styles.score}>{match.homeScore}</Text>\n        </View>\n        \n        <View style={styles.teamRow}>\n          <TouchableOpacity\n            style={styles.favoriteButton}\n            onPress={() => handleFavoritePress(match.awayTeam.id)}\n          >\n            <Icon \n              name={favorites.teams.includes(match.awayTeam.id) ? 'star' : 'star-outline'} \n              size={16} \n              color=\"#FFD700\" \n            />\n          </TouchableOpacity>\n          <Text style={styles.teamName}>{match.awayTeam.name}</Text>\n          <Text style={styles.score}>{match.awayScore}</Text>\n        </View>\n      </View>\n      \n      {match.waveScore > 0 && (\n        <View style={styles.waveContainer}>\n          <View style={[styles.waveBar, { width: `${match.waveScore}%` }]} />\n          <Text style={styles.waveScore}>{match.waveScore}</Text>\n        </View>\n      )}\n    </TouchableOpacity>\n  );\n};\n\nconst styles = StyleSheet.create({\n  // Styles implementation\n});\n\nexport default MatchCard;\n```",
      "testStrategy": "1. Test match list rendering\n2. Verify league navigation\n3. Test match card component\n4. Validate favorite filtering\n5. Test live score updates\n6. Verify match status indicators\n7. Test pull-to-refresh functionality\n8. Validate smooth animations\n9. Test performance with large lists\n10. Verify responsive design on different screen sizes",
      "priority": "high",
      "dependencies": [
        10
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Implement Wave Detector UI",
      "description": "Develop the user interface for the Wave Detector feature, including the visual wave representation, Rising Tides identification, and Weekend Navigator map.",
      "details": "1. Create Wave Score visualization component\n2. Implement Rising Tides UI\n3. Develop Weekend Navigator map\n4. Add Wave Score details view\n5. Implement personalization controls\n6. Create Wave Score notifications UI\n7. Add animations for wave movements\n\n```javascript\n// src/components/WaveScore.js\nimport React from 'react';\nimport { View, Text, StyleSheet, Animated } from 'react-native';\nimport { LineChart } from 'react-native-chart-kit';\n\nconst WaveScore = ({ score, history, size = 'medium' }) => {\n  // Determine styling based on size\n  const containerStyle = size === 'small' ? styles.smallContainer : styles.container;\n  const scoreStyle = size === 'small' ? styles.smallScore : styles.score;\n  \n  // Determine color based on score\n  const getScoreColor = (score) => {\n    if (score >= 80) return '#FF4500'; // High significance\n    if (score >= 60) return '#FFA500'; // Medium-high significance\n    if (score >= 40) return '#FFD700'; // Medium significance\n    if (score >= 20) return '#ADFF2F'; // Medium-low significance\n    return '#90EE90'; // Low significance\n  };\n  \n  const color = getScoreColor(score);\n  \n  // For small size, just show the number with colored background\n  if (size === 'small') {\n    return (\n      <View style={[containerStyle, { backgroundColor: color }]}>\n        <Text style={scoreStyle}>{Math.round(score)}</Text>\n      </View>\n    );\n  }\n  \n  // For medium/large size, show the wave visualization\n  return (\n    <View style={containerStyle}>\n      <Text style={scoreStyle}>{Math.round(score)}</Text>\n      \n      {history && history.length > 1 && (\n        <LineChart\n          data={{\n            labels: [],\n            datasets: [{\n              data: history.slice(-10), // Last 10 data points\n            }],\n          }}\n          width={120}\n          height={60}\n          chartConfig={{\n            backgroundColor: 'transparent',\n            backgroundGradientFrom: 'white',\n            backgroundGradientTo: 'white',\n            decimalPlaces: 0,\n            color: () => color,\n            labelColor: () => 'transparent',\n            style: {\n              borderRadius: 16,\n            },\n            propsForDots: {\n              r: '0',\n            },\n          }}\n          bezier\n          style={styles.chart}\n          withDots={false}\n          withInnerLines={false}\n          withOuterLines={false}\n          withHorizontalLabels={false}\n          withVerticalLabels={false}\n        />\n      )}\n      \n      <View style={[styles.waveBar, { width: `${score}%`, backgroundColor: color }]} />\n    </View>\n  );\n};\n\n// src/screens/WeekendNavigatorScreen.js\nimport React, { useState, useEffect } from 'react';\nimport { View, Text, StyleSheet, FlatList, TouchableOpacity } from 'react-native';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { Calendar } from 'react-native-calendars';\n\nimport { fetchUpcomingMatches } from '../store/actions/matchActions';\nimport MatchCard from '../components/MatchCard';\nimport WaveScore from '../components/WaveScore';\n\nconst WeekendNavigatorScreen = ({ navigation }) => {\n  const [selectedDate, setSelectedDate] = useState(new Date().toISOString().split('T')[0]);\n  const dispatch = useDispatch();\n  const { upcomingMatches, loading } = useSelector(state => state.matches);\n  \n  useEffect(() => {\n    dispatch(fetchUpcomingMatches(selectedDate));\n  }, [dispatch, selectedDate]);\n  \n  // Generate marked dates for the calendar\n  const getMarkedDates = () => {\n    const marked = {};\n    \n    // Group matches by date\n    const matchesByDate = upcomingMatches.reduce((acc, match) => {\n      const date = new Date(match.startTime).toISOString().split('T')[0];\n      if (!acc[date]) acc[date] = [];\n      acc[date].push(match);\n      return acc;\n    }, {});\n    \n    // Find max wave score for each date\n    Object.entries(matchesByDate).forEach(([date, matches]) => {\n      const maxWaveScore = Math.max(...matches.map(m => m.predictedWaveScore || 0));\n      let dotColor = '#90EE90';\n      \n      if (maxWaveScore >= 80) dotColor = '#FF4500';\n      else if (maxWaveScore >= 60) dotColor = '#FFA500';\n      else if (maxWaveScore >= 40) dotColor = '#FFD700';\n      else if (maxWaveScore >= 20) dotColor = '#ADFF2F';\n      \n      marked[date] = {\n        marked: true,\n        dotColor,\n        selected: date === selectedDate,\n        selectedColor: '#E0E0E0',\n      };\n    });\n    \n    return marked;\n  };\n  \n  const filteredMatches = upcomingMatches.filter(match => {\n    const matchDate = new Date(match.startTime).toISOString().split('T')[0];\n    return matchDate === selectedDate;\n  });\n  \n  // Sort by predicted wave score\n  const sortedMatches = [...filteredMatches].sort((a, b) => \n    (b.predictedWaveScore || 0) - (a.predictedWaveScore || 0)\n  );\n  \n  return (\n    <View style={styles.container}>\n      <Calendar\n        markedDates={getMarkedDates()}\n        onDayPress={day => setSelectedDate(day.dateString)}\n        theme={{\n          selectedDayBackgroundColor: '#4285F4',\n          todayTextColor: '#4285F4',\n          arrowColor: '#4285F4',\n        }}\n      />\n      \n      <View style={styles.matchesContainer}>\n        <Text style={styles.dateTitle}>\n          {new Date(selectedDate).toLocaleDateString(undefined, { weekday: 'long', month: 'long', day: 'numeric' })}\n        </Text>\n        \n        {loading ? (\n          <ActivityIndicator size=\"large\" color=\"#4285F4\" />\n        ) : (\n          <FlatList\n            data={sortedMatches}\n            keyExtractor={item => item.id.toString()}\n            renderItem={({ item }) => (\n              <TouchableOpacity \n                style={styles.matchItem}\n                onPress={() => navigation.navigate('MatchDetails', { matchId: item.id })}\n              >\n                <View style={styles.matchInfo}>\n                  <Text style={styles.matchTime}>\n                    {new Date(item.startTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}\n                  </Text>\n                  <Text style={styles.matchName}>\n                    {item.homeTeam.name} vs {item.awayTeam.name}\n                  </Text>\n                  <Text style={styles.leagueName}>{item.league.name}</Text>\n                </View>\n                \n                <WaveScore \n                  score={item.predictedWaveScore || 0} \n                  size=\"small\" \n                />\n              </TouchableOpacity>\n            )}\n            ListEmptyComponent={\n              <Text style={styles.emptyText}>No matches scheduled for this date</Text>\n            }\n          />\n        )}\n      </View>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  // Styles implementation\n});\n\nexport default WeekendNavigatorScreen;\n```",
      "testStrategy": "1. Test Wave Score visualization\n2. Verify Rising Tides UI\n3. Test Weekend Navigator map\n4. Validate Wave Score details view\n5. Test personalization controls\n6. Verify Wave Score notifications UI\n7. Test animations for wave movements\n8. Validate color coding based on Wave Score\n9. Test responsiveness on different screen sizes\n10. Verify accessibility features",
      "priority": "medium",
      "dependencies": [
        6,
        11
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Implement Memory Avenues UI",
      "description": "Develop the user interface for the Memory Avenues feature, including visual pathways, thematic routes, pivotal moment highlighting, and avenue sharing capabilities.",
      "details": "1. Create avenue visualization component\n2. Implement thematic route selection\n3. Develop pivotal moment highlighting\n4. Add quick journey navigation\n5. Implement avenue sharing\n6. Create personalized avenue views\n7. Add animations for pathway navigation\n\n```javascript\n// src/screens/MemoryAvenueScreen.js\nimport React, { useState, useEffect, useRef } from 'react';\nimport { View, Text, StyleSheet, FlatList, TouchableOpacity, Share, Animated } from 'react-native';\nimport { useSelector, useDispatch } from 'react-redux';\nimport Icon from 'react-native-vector-icons/MaterialCommunityIcons';\n\nimport { fetchMatchAvenues } from '../store/actions/avenueActions';\nimport MomentCard from '../components/MomentCard';\nimport RouteSelector from '../components/RouteSelector';\nimport LoadingIndicator from '../components/LoadingIndicator';\n\nconst MemoryAvenueScreen = ({ route, navigation }) => {\n  const { matchId } = route.params;\n  const [selectedRoute, setSelectedRoute] = useState('main');\n  const [expandedMoment, setExpandedMoment] = useState(null);\n  const scrollViewRef = useRef(null);\n  \n  const dispatch = useDispatch();\n  const { avenues, loading, error } = useSelector(state => state.avenues);\n  const { match } = useSelector(state => state.matches.matches.find(m => m.id === matchId) || {});\n  \n  useEffect(() => {\n    dispatch(fetchMatchAvenues(matchId));\n  }, [dispatch, matchId]);\n  \n  const currentAvenue = avenues.find(a => a.matchId === matchId && a.type === selectedRoute);\n  \n  const handleRouteChange = (routeType) => {\n    setSelectedRoute(routeType);\n    setExpandedMoment(null);\n    // Scroll to top when changing routes\n    if (scrollViewRef.current) {\n      scrollViewRef.current.scrollToOffset({ offset: 0, animated: true });\n    }\n  };\n  \n  const handleMomentPress = (momentId) => {\n    setExpandedMoment(expandedMoment === momentId ? null : momentId);\n  };\n  \n  const handleShare = async () => {\n    try {\n      const result = await Share.share({\n        message: `Check out this ${selectedRoute} avenue for ${match?.homeTeam.name} vs ${match?.awayTeam.name} on Futave!`,\n        url: `https://futave.app/avenues/${matchId}/${selectedRoute}`,\n      });\n    } catch (error) {\n      console.error('Error sharing avenue:', error);\n    }\n  };\n  \n  if (loading) {\n    return <LoadingIndicator />;\n  }\n  \n  if (error) {\n    return (\n      <View style={styles.errorContainer}>\n        <Text style={styles.errorText}>Failed to load avenue: {error}</Text>\n        <TouchableOpacity \n          style={styles.retryButton}\n          onPress={() => dispatch(fetchMatchAvenues(matchId))}\n        >\n          <Text style={styles.retryText}>Retry</Text>\n        </TouchableOpacity>\n      </View>\n    );\n  }\n  \n  if (!currentAvenue) {\n    return (\n      <View style={styles.errorContainer}>\n        <Text style={styles.errorText}>No avenue available for this match</Text>\n      </View>\n    );\n  }\n  \n  return (\n    <View style={styles.container}>\n      <View style={styles.header}>\n        <Text style={styles.title}>{currentAvenue.title}</Text>\n        <Text style={styles.subtitle}>{currentAvenue.description}</Text>\n        <Text style={styles.readTime}>Estimated read: {currentAvenue.estimatedReadTime} min</Text>\n      </View>\n      \n      <RouteSelector\n        selectedRoute={selectedRoute}\n        onRouteChange={handleRouteChange}\n        availableRoutes={avenues\n          .filter(a => a.matchId === matchId)\n          .map(a => ({ type: a.type, title: a.type.charAt(0).toUpperCase() + a.type.slice(1) }))\n        }\n      />\n      \n      <FlatList\n        ref={scrollViewRef}\n        data={currentAvenue.moments}\n        keyExtractor={item => item.id}\n        renderItem={({ item, index }) => (\n          <MomentCard\n            moment={item}\n            isExpanded={expandedMoment === item.id}\n            onPress={() => handleMomentPress(item.id)}\n            isFirst={index === 0}\n            isLast={index === currentAvenue.moments.length - 1}\n          />\n        )}\n        contentContainerStyle={styles.momentsList}\n        ItemSeparatorComponent={() => (\n          <View style={styles.pathLine} />\n        )}\n      />\n      \n      <TouchableOpacity style={styles.shareButton} onPress={handleShare}>\n        <Icon name=\"share-variant\" size={24} color=\"white\" />\n        <Text style={styles.shareText}>Share Avenue</Text>\n      </TouchableOpacity>\n    </View>\n  );\n};\n\n// src/components/MomentCard.js\nimport React from 'react';\nimport { View, Text, StyleSheet, TouchableOpacity, Image, Animated } from 'react-native';\nimport Icon from 'react-native-vector-icons/MaterialCommunityIcons';\n\nconst MomentCard = ({ moment, isExpanded, onPress, isFirst, isLast }) => {\n  const getIconForMomentType = (type) => {\n    switch (type) {\n      case 'goal': return 'soccer';\n      case 'card': return 'card';\n      case 'substitution': return 'account-switch';\n      case 'chance': return 'target';\n      case 'tactical': return 'strategy';\n      default: return 'information-outline';\n    }\n  };\n  \n  const getColorForMomentType = (type) => {\n    switch (type) {\n      case 'goal': return '#FF4500';\n      case 'card': return '#FFD700';\n      case 'substitution': return '#4285F4';\n      case 'chance': return '#FFA500';\n      case 'tactical': return '#9C27B0';\n      default: return '#757575';\n    }\n  };\n  \n  const iconName = getIconForMomentType(moment.type);\n  const iconColor = getColorForMomentType(moment.type);\n  \n  return (\n    <View style={styles.container}>\n      <View style={styles.timelineContainer}>\n        {!isFirst && <View style={styles.lineTop} />}\n        <View style={[styles.dot, { backgroundColor: iconColor }]}>\n          <Icon name={iconName} size={16} color=\"white\" />\n        </View>\n        {!isLast && <View style={styles.lineBottom} />}\n      </View>\n      \n      <TouchableOpacity \n        style={[styles.card, isExpanded && styles.expandedCard]}\n        onPress={onPress}\n        activeOpacity={0.7}\n      >\n        <View style={styles.header}>\n          <Text style={styles.timestamp}>{moment.timestamp}'</Text>\n          <Text style={styles.title}>{moment.description}</Text>\n          <Icon \n            name={isExpanded ? 'chevron-up' : 'chevron-down'} \n            size={20} \n            color=\"#757575\" \n          />\n        </View>\n        \n        {isExpanded && (\n          <View style={styles.expandedContent}>\n            {moment.media && (\n              <Image \n                source={{ uri: moment.media }} \n                style={styles.media} \n                resizeMode=\"cover\"\n              />\n            )}\n            <Text style={styles.detailedDescription}>\n              {/* More detailed description would go here */}\n              This is a detailed description of the moment, providing context and significance.\n            </Text>\n          </View>\n        )}\n      </TouchableOpacity>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  // Styles implementation\n});\n\nexport default MomentCard;\n```",
      "testStrategy": "1. Test avenue visualization\n2. Verify thematic route selection\n3. Test pivotal moment highlighting\n4. Validate quick journey navigation\n5. Test avenue sharing\n6. Verify personalized avenue views\n7. Test animations for pathway navigation\n8. Validate different moment types display correctly\n9. Test responsiveness on different screen sizes\n10. Verify accessibility features",
      "priority": "medium",
      "dependencies": [
        7,
        11
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "Implement User Preferences and Personalization",
      "description": "Develop the user interface and functionality for managing user preferences, favorites, and personalization settings to provide a customized experience.",
      "details": "1. Create user profile screen\n2. Implement favorite teams, leagues, and players management\n3. Develop notification preferences UI\n4. Add Wave Score personalization settings\n5. Implement account management\n6. Create onboarding flow for new users\n7. Add preference sync with backend\n\n```javascript\n// src/screens/ProfileScreen.js\nimport React, { useState, useEffect } from 'react';\nimport { View, Text, StyleSheet, ScrollView, Switch, TouchableOpacity, Alert } from 'react-native';\nimport { useSelector, useDispatch } from 'react-redux';\nimport Icon from 'react-native-vector-icons/MaterialCommunityIcons';\n\nimport { \n  updateNotificationPreferences, \n  updateWaveScorePreferences,\n  logout,\n  deleteAccount\n} from '../store/actions/userActions';\nimport { fetchUserProfile } from '../store/actions/userActions';\nimport FavoritesList from '../components/FavoritesList';\nimport PreferenceSlider from '../components/PreferenceSlider';\nimport LoadingIndicator from '../components/LoadingIndicator';\n\nconst ProfileScreen = ({ navigation }) => {\n  const dispatch = useDispatch();\n  const { user, loading, error } = useSelector(state => state.user);\n  const [notificationPrefs, setNotificationPrefs] = useState({\n    goals: true,\n    matchStart: true,\n    highWaveScore: true,\n    waveScoreThreshold: 70,\n  });\n  const [wavePrefs, setWavePrefs] = useState({\n    favoriteTeamBoost: 1.2,\n    favoriteLeagueBoost: 1.1,\n    rivalryImportance: 0.8,\n    tableImpactImportance: 0.7,\n  });\n  \n  useEffect(() => {\n    dispatch(fetchUserProfile());\n  }, [dispatch]);\n  \n  useEffect(() => {\n    if (user?.notificationPreferences) {\n      setNotificationPrefs(user.notificationPreferences);\n    }\n    if (user?.waveScorePreferences) {\n      setWavePrefs(user.waveScorePreferences);\n    }\n  }, [user]);\n  \n  const handleNotificationToggle = (key) => {\n    const updatedPrefs = { ...notificationPrefs, [key]: !notificationPrefs[key] };\n    setNotificationPrefs(updatedPrefs);\n    dispatch(updateNotificationPreferences(updatedPrefs));\n  };\n  \n  const handleWaveScoreThresholdChange = (value) => {\n    const updatedPrefs = { ...notificationPrefs, waveScoreThreshold: value };\n    setNotificationPrefs(updatedPrefs);\n    dispatch(updateNotificationPreferences(updatedPrefs));\n  };\n  \n  const handleWavePrefChange = (key, value) => {\n    const updatedPrefs = { ...wavePrefs, [key]: value };\n    setWavePrefs(updatedPrefs);\n    dispatch(updateWaveScorePreferences(updatedPrefs));\n  };\n  \n  const handleLogout = () => {\n    Alert.alert(\n      'Logout',\n      'Are you sure you want to log out?',\n      [\n        { text: 'Cancel', style: 'cancel' },\n        { text: 'Logout', style: 'destructive', onPress: () => dispatch(logout()) },\n      ]\n    );\n  };\n  \n  const handleDeleteAccount = () => {\n    Alert.alert(\n      'Delete Account',\n      'Are you sure you want to delete your account? This action cannot be undone.',\n      [\n        { text: 'Cancel', style: 'cancel' },\n        { \n          text: 'Delete', \n          style: 'destructive', \n          onPress: () => {\n            dispatch(deleteAccount());\n          } \n        },\n      ]\n    );\n  };\n  \n  if (loading) {\n    return <LoadingIndicator />;\n  }\n  \n  return (\n    <ScrollView style={styles.container}>\n      <View style={styles.header}>\n        <Icon name=\"account-circle\" size={80} color=\"#4285F4\" />\n        <Text style={styles.username}>{user?.email || 'Guest User'}</Text>\n      </View>\n      \n      <View style={styles.section}>\n        <Text style={styles.sectionTitle}>Favorites</Text>\n        <FavoritesList \n          type=\"teams\" \n          favorites={user?.favoriteTeams || []} \n          onManageFavorites={() => navigation.navigate('ManageFavorites', { type: 'teams' })}\n        />\n        <FavoritesList \n          type=\"leagues\" \n          favorites={user?.favoriteLeagues || []} \n          onManageFavorites={() => navigation.navigate('ManageFavorites', { type: 'leagues' })}\n        />\n        <FavoritesList \n          type=\"players\" \n          favorites={user?.favoritePlayers || []} \n          onManageFavorites={() => navigation.navigate('ManageFavorites', { type: 'players' })}\n        />\n      </View>\n      \n      <View style={styles.section}>\n        <Text style={styles.sectionTitle}>Notifications</Text>\n        \n        <View style={styles.preferenceItem}>\n          <Text style={styles.preferenceLabel}>Goal Alerts</Text>\n          <Switch\n            value={notificationPrefs.goals}\n            onValueChange={() => handleNotificationToggle('goals')}\n            trackColor={{ false: '#767577', true: '#81b0ff' }}\n            thumbColor={notificationPrefs.goals ? '#4285F4' : '#f4f3f4'}\n          />\n        </View>\n        \n        <View style={styles.preferenceItem}>\n          <Text style={styles.preferenceLabel}>Match Start</Text>\n          <Switch\n            value={notificationPrefs.matchStart}\n            onValueChange={() => handleNotificationToggle('matchStart')}\n            trackColor={{ false: '#767577', true: '#81b0ff' }}\n            thumbColor={notificationPrefs.matchStart ? '#4285F4' : '#f4f3f4'}\n          />\n        </View>\n        \n        <View style={styles.preferenceItem}>\n          <Text style={styles.preferenceLabel}>High Wave Score</Text>\n          <Switch\n            value={notificationPrefs.highWaveScore}\n            onValueChange={() => handleNotificationToggle('highWaveScore')}\n            trackColor={{ false: '#767577', true: '#81b0ff' }}\n            thumbColor={notificationPrefs.highWaveScore ? '#4285F4' : '#f4f3f4'}\n          />\n        </View>\n        \n        {notificationPrefs.highWaveScore && (\n          <View style={styles.sliderContainer}>\n            <Text style={styles.sliderLabel}>\n              Wave Score Threshold: {notificationPrefs.waveScoreThreshold}\n            </Text>\n            <PreferenceSlider\n              value={notificationPrefs.waveScoreThreshold}\n              onValueChange={handleWaveScoreThresholdChange}\n              minimumValue={50}\n              maximumValue={90}\n              step={5}\n            />\n          </View>\n        )}\n      </View>\n      \n      <View style={styles.section}>\n        <Text style={styles.sectionTitle}>Wave Score Personalization</Text>\n        \n        <View style={styles.sliderContainer}>\n          <Text style={styles.sliderLabel}>\n            Favorite Team Boost: {wavePrefs.favoriteTeamBoost.toFixed(1)}x\n          </Text>\n          <PreferenceSlider\n            value={wavePrefs.favoriteTeamBoost}\n            onValueChange={(value) => handleWavePrefChange('favoriteTeamBoost', value)}\n            minimumValue={1.0}\n            maximumValue={2.0}\n            step={0.1}\n          />\n        </View>\n        \n        <View style={styles.sliderContainer}>\n          <Text style={styles.sliderLabel}>\n            Favorite League Boost: {wavePrefs.favoriteLeagueBoost.toFixed(1)}x\n          </Text>\n          <PreferenceSlider\n            value={wavePrefs.favoriteLeagueBoost}\n            onValueChange={(value) => handleWavePrefChange('favoriteLeagueBoost', value)}\n            minimumValue={1.0}\n            maximumValue={2.0}\n            step={0.1}\n          />\n        </View>\n        \n        {/* Other wave preferences */}\n      </View>\n      \n      <View style={styles.section}>\n        <Text style={styles.sectionTitle}>Account</Text>\n        \n        <TouchableOpacity style={styles.button} onPress={handleLogout}>\n          <Icon name=\"logout\" size={20} color=\"#4285F4\" />\n          <Text style={styles.buttonText}>Logout</Text>\n        </TouchableOpacity>\n        \n        <TouchableOpacity style={styles.dangerButton} onPress={handleDeleteAccount}>\n          <Icon name=\"delete\" size={20} color=\"#FF4500\" />\n          <Text style={styles.dangerButtonText}>Delete Account</Text>\n        </TouchableOpacity>\n      </View>\n    </ScrollView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  // Styles implementation\n});\n\nexport default ProfileScreen;\n```",
      "testStrategy": "1. Test user profile screen\n2. Verify favorites management\n3. Test notification preferences\n4. Validate Wave Score personalization\n5. Test account management\n6. Verify onboarding flow\n7. Test preference sync with backend\n8. Validate data persistence\n9. Test UI on different screen sizes\n10. Verify accessibility features",
      "priority": "medium",
      "dependencies": [
        8,
        10
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "Implement App Testing and Performance Optimization",
      "description": "Develop comprehensive testing for the application and implement performance optimizations to ensure the app meets the specified performance requirements.",
      "details": "1. Implement unit tests for core functionality\n2. Create integration tests for key user flows\n3. Set up end-to-end testing\n4. Implement performance monitoring\n5. Optimize API request caching\n6. Implement image optimization\n7. Add error tracking and reporting\n8. Optimize animations and transitions\n9. Implement memory usage optimization\n10. Create automated testing pipeline\n\n```javascript\n// tests/unit/waveDetector.test.js\nimport { calculateWaveScore } from '../../src/services/waveDetector';\n\ndescribe('Wave Detector', () => {\n  test('should calculate correct wave score for close match in late game', () => {\n    const match = {\n      homeScore: 1,\n      awayScore: 1,\n      minute: 85,\n      league: 'premier-league',\n      homeTeam: { id: 'team1' },\n      awayTeam: { id: 'team2' },\n      events: [],\n    };\n    \n    const score = calculateWaveScore(match);\n    expect(score).toBeGreaterThan(50); // Close match in late game should have high score\n  });\n  \n  test('should boost score for user favorite teams', () => {\n    const match = {\n      homeScore: 1,\n      awayScore: 0,\n      minute: 70,\n      league: 'premier-league',\n      homeTeam: { id: 'team1' },\n      awayTeam: { id: 'team2' },\n      events: [],\n    };\n    \n    const userPreferences = {\n      favoriteTeams: ['team1'],\n      favoriteLeagues: [],\n    };\n    \n    const baseScore = calculateWaveScore(match);\n    const personalizedScore = calculateWaveScore(match, userPreferences);\n    \n    expect(personalizedScore).toBeGreaterThan(baseScore);\n  });\n});\n\n// src/utils/performance.js\nimport { InteractionManager } from 'react-native';\n\n// Run heavy tasks after animations complete\nexport function runAfterInteractions(task) {\n  InteractionManager.runAfterInteractions(() => {\n    task();\n  });\n}\n\n// Debounce function to limit frequent calls\nexport function debounce(func, wait) {\n  let timeout;\n  return function(...args) {\n    const context = this;\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(context, args), wait);\n  };\n}\n\n// Memoize expensive calculations\nexport function memoize(func) {\n  const cache = new Map();\n  return function(...args) {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    const result = func.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// API request caching\nexport class ApiCache {\n  constructor(ttl = 60000) { // Default TTL: 1 minute\n    this.cache = new Map();\n    this.ttl = ttl;\n  }\n  \n  async get(key, fetchFunc) {\n    const now = Date.now();\n    const cached = this.cache.get(key);\n    \n    if (cached && now - cached.timestamp < this.ttl) {\n      return cached.data;\n    }\n    \n    const data = await fetchFunc();\n    this.cache.set(key, { data, timestamp: now });\n    return data;\n  }\n  \n  invalidate(key) {\n    this.cache.delete(key);\n  }\n  \n  clear() {\n    this.cache.clear();\n  }\n}\n\n// Usage in API client\nimport { ApiCache } from '../utils/performance';\n\nconst apiCache = new ApiCache();\n\nexport async function fetchMatches(leagueId, status, silent = false) {\n  const cacheKey = `matches_${leagueId}_${status}`;\n  \n  // Only use cache for non-live data or silent updates\n  if (status !== 'live' || silent) {\n    return apiCache.get(cacheKey, async () => {\n      const response = await apiClient.get(`/matches`, {\n        params: { league: leagueId, status },\n      });\n      return response.data;\n    });\n  }\n  \n  // For live data, always fetch fresh\n  const response = await apiClient.get(`/matches`, {\n    params: { league: leagueId, status },\n  });\n  return response.data;\n}\n```",
      "testStrategy": "1. Run unit tests for all core services\n2. Execute integration tests for key user flows\n3. Perform end-to-end testing on multiple devices\n4. Measure and verify performance metrics:\n   - App launch time < 2 seconds\n   - Score updates < 3 seconds\n   - Smooth scrolling at 60fps\n   - Memory usage within acceptable limits\n5. Test API request caching\n6. Verify image optimization\n7. Test error tracking and reporting\n8. Validate animations and transitions\n9. Monitor memory usage during extended use\n10. Run automated testing pipeline before deployment",
      "priority": "high",
      "dependencies": [
        11,
        12,
        13,
        14
      ],
      "status": "pending",
      "subtasks": []
    }
  ]
}